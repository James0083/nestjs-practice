# 18. 테스트 자동화

## 18.1 소프트웨어 테스트

버그가 없는 소프트웨어는 존재하지 않는다.

아무리 간단한 프로그램이라 할지라도 그 프로그램이 수행되는 시스템이나 상황에 다라 제대로 동작하지 않을 가능성은 얼마든지 존재한다.

더군다나 상용 소프트웨어와 같이 복잡한 프로그램이 함께 맞물려 돌아가는 시스템에서는 각종 버그가 숨어 있기 마련이고 이는 사용자를 불편하게 하고 개발자를 괴롭힌다.

모든 제품은 릴리스 전에 테스트를 통과해야 한다.

소프트웨어도 마찬가지다.

일반적으로 품질보증(quality assurance, QA)라고 불리는 테스트 작업을 수행한다.

QA의 A가 assurance인 것을 곱씹어볼만하다.

소프트웨어 테스팅 과정은 버그가 없다고 확신하는게 아니라 소프트웨어의 품질이 사용자에게 전달될 정도의 수준이 되었다는 것을 보증하는 과정이다.

따라서 테스트로 모든 버그를 발견할 수도 없지만 그 과정 중에 발견한 모든 버그를 수정할 필요도 없다.

가능한 일정 내에 소비자에게 최대한의 가치를 전달할 수준으로 만드는 것이 최대의 이익을 가져다 줄 수 있다.

소프트웨어 개발 프로세스에서의 테스트는 분류 방법에 따라 그 종류가 다양하다.

먼저 개발 단계에 따른 분류로 [V모델(V-model)](https://ko.wikipedia.org/wiki/V_모델)을 사용한다.

보통 업무의 진행은 좌상단 요구 사항 분석에서 시작해서 시스템 설계, 아키텍처 설계, 모둘 설계(또는 상세 설계), 코딩으로 진행된다.

테스트는 각 단계와 대응되는 테스트 과정을 역순으로 수행한다.

이 개발 방법론이 폭포수 모델로서, 현대 개발 방법론에 들어맞지 않는다고 생각할 수 있겠지만 이 과정을 소수의 백로그로 이터레이션마다 애자일하게 수행한다고 생각하면 된다.

![V-model.jpg](https://upload.wikimedia.org/wikipedia/commons/9/96/V-model.JPG)

표로 나타내면 다음과 같다.

| 개발 단계 | 테스트 종류 | 내용 |
| --- | --- | --- |
| 요구 사항 분석
(requirements analysis) | 인수 테스트
(acceptance testing) | 알파, 베타 테스트와 같이 실사용 환경에서의 문제를 확인한다.
이 테스트의 목적은 시스템을 운영 환경에 배포할 준비가 되었는지를 확인하는 것이 목적이다. |
| 시스템 설계
(system design) | 시스템 테스트
(system testing) | 소프트웨어가 구동되는 환경의 제약 사항으로 인해 발생하는 문제를 찾기 위한 테스트이다.
테스트 방법
- 회복 테스트(recovery test): 전전 등과 같은 유사한 상황 발생시 자동 초기화, 데이터 회복이 제대로 되는지 확인한다.
- 보안 테스트(security test): 해킹 공격에 안전한지 확인한다.
- 강도 테스트(stress test): 급격한 트래픽 증가와 같이 큰 부하에 대해 안전한지 테스트 한다.
- 민감도 테스트(sensitivity test): 잘못된 데이터 타입을 가지는 데이터를 입력으로 넣거나, 경곗값이 제대로 동작하는지 확인한다.
- 성능 테스트(performance test): 응답 시간, 응답 처리량 등 시스템의 자원이 효율적으로 사용되고 있는지 확인한다. |
| 아키텍처 설계
(architecture design) | 통합 테스트
(integration testing) | 각 모듈이 제대로 작성되었다면 이제 여러 모듈이 함께 동작했을 때 문제가 없는지 검증하는 과정이다.
상향식 통합, 하향식 통합, 백본 통합 등의 방식이 있다.
코드 레벨에서 코드를 파악하지 않고 수행하기 때문에 블랙박스 테스트라고도 한다. |
| 모듈 설계
(module design) | 단위 테스트
(unit testing) | 테스트 과정에서 가장 먼저 수행되는 테스트이다.
소프트웨어의 코드가 제대로 동작하는지 저수준의 테스트 코드를 작성하여 검증한다.
따라서 코드를 제대로 파악하고 있는 개발자 자신이 테스트 코드를 작성하는 것이 대부분이지만 테스트 엔지니어가 테스트 코드를 작성하기도 한다.
테스트 엔지니어가 코드 작성 능력이 있고 가용자원이 있다면 테스트 엔지니어가 작성하는 것이 좋은데 테스트 엔지니어의 전문성을 살려 개발자가 예상하지 못했던 테스트 케이스를 만들 수 있기 때문이다.
개발자와 테스트 엔지니어가 함께 작성하는 것도 좋은 방법이다. |
| 코딩
(coding) | 디버깅
(debugging) | 개발자가 직접 코드의 로직을 검증하고 오류를 디버깅하는 과정이다.
이는 테스트 과정이라고 할 수 없고 개발과정으로 본다. |

테스트를 프로그램의 실행 여부에 따라 정적 테스트와 동적 테스트로 나눌 수도 있다.

정적 테스트는 코드를 수행하지 않고 검증하는 테스트이다.

전적 분석기(static analyzer)를 이용하여 코드에 내재됨 이슈를 미리 파악해볼 수도 있고, 동료 코드 리뷰를 받는 것도 정적 테스트이 일종이다.

동적 기반 테스트는 직접 프로그램을 실행해보며 진행하는 테스트이다.

작은 조직이라면 개발 프로세스에 뒤 테스트 과정이 모두 포함되지 않는 경우도 있고 모든 테스트를 개발자가 직접 수행하기도 한다.

디버깅은 코딩 과정에서 수행하는 테스트이니 너무 당연하지만, 적어도 단위 테스트는 함께 작성하는 것이 좋다.

V 모델의 테스트 단계에서 위쪽 단계의 테스트로 갈수록 테스트 과정에서 발견되는 이슈를 수정하기 위해 드는 비용은 크게 증가하게 된다.

테스트 코드를 작성하는 것이 개발 속도를 더 느리게 만든다고 느껴질 수도 있겠지만 오히려 그 반대이다.

안정된 테스트 코드가 존재하면 리팩터링을 마음 편하게 할 수 있다.

내가 지금 고치는 코드가 기존 시스템의 동작을 깨뜨리지 않을 까 하는 걱정하지 않아도 된다.

잘 만들고 관리되는 테스트 코드는 결국 소프트웨어의 품질을 개선하는 데 도움이 된다.

**테스트 주도 개발**(test-driven development, TDD)을 활용하여 테스트 코드를 먼저 작성하고 이를 기반으로 실제 소프트웨어의 코드를 작성해나가는 방법론도 있다.

'모자 바꿔 쓰기'라고도 불리는데 테스트 엔지니어와 개발 엔지니어의 역할을 바꿔가면서 테스트 케이스를 풍부하게 작성할 수 있다.

지금 시간이 없어 테스트 코드를 작성하지 않았다면 내일 잠시 다른 일을 미뤄두고 테스트 코드를 작성해라.

시스템이 복잡해서 더 이상 모든 테스트를 손으로 하지 못할 지경이 되었을 때 미뤄둔 숙제를 한 번에 하게 된다면 행복하지 못할 것이다.

테스트 코드는 단위 테스트 코드만을 의미하지는 않는다.

E2E(end-to-end) 테스트는 사용자의 행동을 코드로 작성한 것이다.

사용자의 어떤 동작이 일어나는지부터 시작해서 모든 시스템을 동적으로 수행한 수 응답을 확인하는 방식이다.

테스트 코드가 잘 준비되었다면 더 나아가 배포 과정에 포함하도록 하자.

지속적 통합(continuous integration, CI) 및 지속적 배포(continuous deployment, CD) 과정에 포함된 자동화 테스트는 통합/배포 과정에서 소스코드 저장소에 버그가 스며드는 것을 방지해준다.

## 18.2 Nest의 기본 테스트 프레임워크: Jest와 SuperTest

자바스크립트에는 많은 테스트 프레임워크가 존재한다.

테스트 프레임워크의 구성 요소로서 테스트가 실행되는 환경을 제공하는 테스트 **러너**(test runner), 테스트의 상황을 가정하는 **어서션**(assertion), 테스트의 기대 결과를 비교하는 **매처**(matcher), 그리고 테스트 과정에서 현재 테스트 대상 모듈이 의존하는 다른 모듈을 임의의 것으로 대체하는 **테스트 더블** 등이 있다.

Nest는 기본 테스트 프레임워크로 Jest와 SuperTest를 제공한다.

[Jest](https://jestjs.io/)는 메타가 주도해서 만든 테스트 프레임워크이다.

문법이 심플하고 Nest뿐 아니라 Babel, 타입스크립트, Node.js, 리액트, 앵귤러, Vue.js에 적용하여 사용할 수 있다.

SuperTest는 superagent라이브러리를 기반으로 하는 HTTP 테스틀 라이브러리이다.

SuperTest를 이용하면 컨트롤러가 제공하는 엔드 포인트로 호출하는 것과 같은 E2E 테스트를 작성할 수 있다.

이 책에서는 SuperTest를 이용한 테스트는 소개하지 않으며, 단위 테스트만 사용한다.

단위 테스트만 잘 작성해도 테스트 코드를 작성하기로 했던 목적을 충분히 달성할 수 있다.

또 단위 테스트를 작성하는 과정에서 생각하지 못했던 에지 케이스나 설계의 오류를 발견할 수 있을 것이다.

## 18.3 Jest를 이용한 단위 테스트 예시

Nest CLI를 이용한 프로젝트를 생성하면 기본 컴포넌트와 함께 해당 컴포넌트에 대한 테스트 파일이 생성된다.

1장 예제 소스를 보면 app.controller.spec.ts파일이 생성되어 있다.

자동 생성된 테스트 코드는 Jest를 이용한다.

테스트코드의 파일명은 .spec.ts로 끝나야 한다.

이 규칙은 package.json에 정의되어 있다.

(나머지 옵션들은 [공식문서](https://jestjs.io/docs/configuration)를 확인)

```tsx
//package.json
{
	...
	"jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",  //1
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}
```

> 1) 테스트 코드 파일의 확장자 형식을 정규 표현식으로 선언한다.
> 

테스트 코드는 describe()와 it() 구문으로 구성된다.

describe()는 테스트 스위트(test suite)를 작성하는 블록이다.

테스트 스위트는 테스트들을 의미있는 단위로 묶은 것이다.

테스트 스위트를 모아서 더 큰 단위의 테스트 스위트를 만들 수 있다.

테스트 스위트는 테스트 수행에 필요한 환경설정, 공통 모듈 생성 등과 같이 세부 테스트 케이스가 수행하기 위한 기반을 마련한다.

it()구문은 특정 테스트 시나리오를 작성하는 부분이다.

각 it()구문은 별개의 테스트 케이스로 다뤄져야 하며 서로 의존관계가 존재하지 않도록 작성하는 것이 중요하다.

테스트 케이스의 작성법도 TDD 스타일로 해야하느냐, BDD(behavior-driven development)스타일을 따라야 하느냐 논쟁이 있지만 둘 다 필요한 방식이다.

우리는 Given / When / Then의 BDD스타일로 테스트 코드를 작성해보자.

- Given : 해당 테스트 케이스가 동작하기 위해 갖춰져야 하는 선행조건(pre-condition)이다. 즉, '**어떤 상황이 주어졌을 때**'를 뜻한다.
- When : 테스트하고자 하는 대상 코드를 실행한다. **'대상코드가 동작한다면'**을 뜻한다.
- Then : 대상 코드의 수행 결과를 판단한다. '**기대한 값과 수행 결과가 맞는지**'를 비교한다.

describe()와 it() 구문은 첫번째 인수로 문자열을 받는다.

이는 테스트 스위트와 테스트 케이스의 이름을 의미한다.

두 번째 인수는 수행될 코드가 포함된 콜백 함수이다.

```tsx
//테스트 코드 예시
describe('UserService', () => {
  const userService: UserService = new UserService();

  describe('create', () => {
    it('should create user', () => {
      //Given
      ...
      //When
      ...
      //Then
      ...
    });

    it('should throw error when user already exists', () => {
      //Given
      ...
      //When
      ...
      //Then
      ...
    });
  });
});
```

describe()와 it() 구문 외에 SetUp, TearDown이라 부르는 개념이 있다.

테스트 스위트 내에서 모든 테스트 케이스를 수행하기 전에 수행해야 하는 선행조건이 있다면 SetUp 구문으로 반복작업을 줄일 수 있다.

마찬가지로 테스트 후에 후처리가 필요하다면 TearDown에서 공통 처리한다.

Jest에서는 beforeAll(), beforeEach(), afterAll(), afterEach() 4가지 구문을 제공한다.

beforeAll()은 테스트 스위트 내의 모든 테스트 케이스 수행 전 한 번만 실행된다.

beforeEach()는 각 테스트 케이스가 수행되기 전마다 수행된다.

afterAll()은 모든 테스트 케이스가 수행된 후에 한번만 실행되고

afterEach()는 각 테스트 케이스가 수행된 후에 실행된다.

테스트는 테스트를 하고자 하는 대상의 동작에만 집중해야 한다.

대상 코드가 수행되면서 주입받거나 생성해서 사용한 외부 모듈이나 객체는 테스트의 대상이 아니다.

외부 모듈은 외부 모듈만을 위한 테스트 코드를 작성해야 한다.

이를 위해서는 외부 모듈의 동작을 우리가 원하는 대로 다룰 수 있어야 한다.

그래야 외부 상태에 상관없이 대상 코드의 동작을 살펴볼 수 있다.

외부 모듈을 임의의 객체로 다루는 것, 이 개념을 테스트 더블(test double)이라고 한다.

테스트 더블을 세부적으로 더미(dummy), 페이크(fake), 스텁(stub), 스파이(spy), 모의 객체(mock)로 나눈다.

**더미** : 테스트를 위해 생성된 가짜 데이터. 일반적으로 매개변수 목록을 채우는 데만 사용된다.

**페이크** : 데이터베이스로 관리되는 다량의 데이터를 테스트한다고 할 때 실제 데이터베이스를 사용할 경우 I/O에 엄청난 시간과 비용이 소요된다.

이럴 때는 인메모리 DB와 같이 메모리에 데이터를 적재해서 속도를 개선할 수 있다.

프로덕션 환경에서는 테스트 수행 도중 시스템이 비정상 종료되는 경우 잘못된 데이터가 남게 되므로, 잘못된 데이터가 남아도 상관없는 세션 등과 같은 것을 대상으로 테스트 할 때 사용한다.

**스파이** : 테스트 수행 정보를 기록한다.

테스트 도중 함수 호출에 대해 해당 함수로 전달된 매개변수, 리턴값, 예외뿐 아니라 함수를 몇 번 호출했는지와 같은 정보들도 기록한다.

**스텁** : 함수 호출 결과를 미리 준비된 응답으로 제공한다.

**모의 객체** : 스텁과 비슷한 역할을 한다.

테스트 중에 만들어진 호출에 미리 준비된 답변을 제공하여 일반적으로 테스트를 위해 프로그래밍된 것 외에는 응답하지 않는다.

[마틴 파울러에 따르면](https://martinfowler.com/articles/mocksArentStubs.html) 테스트 대상이 의존하는 대상의 행위에 대해 검증이 필요하다면 모의 객체를 사용하고 상태를 검증하고자 한다면 스텁을 사용하라고 한다.

## 18.4 유저 서비스 테스트

이제 우리가 만든 서비스에 단위 테스트를 만들어보자.

유저 모듈을 대상으로 테스트 코드를 작성한다.

4개의 레이어로 구성된 각각의 컴포넌트에 대해 테스트 코드를 작성하겠다.

[18.4 유저 서비스 테스트](https://www.notion.so/18-4-2cd1911cea3e4e7eb1f4d7fb4fe0cb49?pvs=21)