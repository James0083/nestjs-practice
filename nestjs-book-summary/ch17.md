# 17. 클린 아키텍처

SW를 작성할 때 모든 것을 처음부터 만들지 않는다.

다른 사람이 작성해둔 소스 코드나 지금 까지 배운 지식화 참고 자료를 활용해서 소프트웨어의 구조를 만들게 된다.

만약 백엔드 프로그래밍을 처음 접했다면 이 책을 읽고 난 뒤 이 책의 구조를 따라할 가능성이 높다.

특히 프레임워크를 학습할 때에는 더욱 그렇다.

Nest를 처음 배웠다면 지금까지 이 책에서 소개한 소스코드가 가지는 아키텍처와 디렉터리 구조가 Nest에서 흔히 쓰이는 것이겠구나 하고 생각할 수도 있다.

지금까지 만든 디렉터리 구조는 다음과 같다.

```
.
├── ormconfig.ts
├── package-lock.json
├── package.json
├── src
│   ├── app.module.ts
│   ├── auth
│   │   ├── auth.module.ts
│   │   └── auth.service.ts
│   ├── auth.guard.ts
│   ├── config
│   │   ├── authConfig.ts
│   │   ├── emailConfig.ts
│   │   ├── env
│   │   │   ├── .development.env
│   │   │   ├── .production.env
│   │   │   └── .stage.env
│   │   └── validationSchema.ts
│   ├── email
│   │   ├── email.module.ts
│   │   └── email.service.ts
│   ├── exception
│   │   ├── exception.module.ts
│   │   └── http-exception.filter.ts
│   ├── health-check
│   │   ├── dog.health.ts
│   │   └── health-check.controller.ts
│   ├── logging
│   │   ├── logging.interceptor.ts
│   │   └── logging.module.ts
│   ├── main.ts
│   ├── migrations
│   │   └── 1640444480113-CreateUserTable.ts
│   ├── users
│   │   ├── UserInfo.ts
│   │   ├── command
│   │   │   ├── create-user.command.ts
│   │   │   ├── create-user.handler.ts
│   │   │   ├── login.command.ts
│   │   │   ├── login.handler.ts
│   │   │   ├── verify-access-token.command.ts
│   │   │   ├── verify-access-token.handler.ts
│   │   │   ├── verify-email.command.ts
│   │   │   └── verify-email.handler.ts
│   │   ├── dto
│   │   │   ├── create-user.dto.ts
│   │   │   ├── user-login.dto.ts
│   │   │   └── verify-email.dto.ts
│   │   ├── entity
│   │   │   └── user.entity.ts
│   │   ├── event
│   │   │   ├── cqrs-event.ts
│   │   │   ├── test.event.ts
│   │   │   ├── user-created.event.ts
│   │   │   └── user-event.handler.ts
│   │   ├── query
│   │   │   ├── get-user-info.handler.ts
│   │   │   └── get-user-info.query.ts
│   │   ├── users.controller.ts
│   │   └── users.module.ts
│   └── utils
│       └── decorators
│           └── not-in.ts
├── tsconfig.build.json
└── tsconfig.json
```

하지만 애플리케이션의 아키텍처에도 유행이 있다.

보통은 점차 나은 방향으로 발전했다.

이제 '클린 아키텍처'라는 아키텍처에 대해 알아보고 유저 서비스의 구조를 개선해보겠다.

좋은 아키텍처를 적용한 샘플 코드가 있다면 앞으로 새로운 애플리케이션을 만들거나 지금 작성하고 있는 SW의 구조를 더 나은 방향으로 개선하는 데 도움이 될 것이다.

최근에는 많은 기업이 MSA를 적용한다.

MSA를 적용했다면 새로운 서비스를 자주 만들게 된다.

이럴 때 매번 바닥부터 다시 애플리케이션을 작성하지 않고 어느 정도 만들어진 소스코드 기반으로 작업을 시작할 수 있게 되는 것이다.

## 17.1 클린 아키텍처

**클린 아키텍처**(clean architecture)는 <클린코드>(인사이트, 2013)의 저자 로버트 C. 마틴이 제안한 아키텍처이다.

클린 아키텍처는 전혀 새로운 아키텍처는 아니고 양파(onion) 아키텍처라고 불리던 아키텍처에서 발전한 것이다.

소프트웨어를 여러 동심원 레이어로 나누고 각 레이어에 있는 컴포넌트는 안쪽 원에 있는 컴포넌트에만 의존성을 가지도록 한다.

따라서 안쪽 원에 존재하는 컴포넌트는 바깥원에 독립적이다.

![CleanArchitecture.jpg](https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg)

[[관련 블로그]](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)   [(yes24)](https://www.yes24.com/Product/Goods/77283734)   [(알라딘)](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=202322454)

이 책에서는 아키텍처를 레이어 4개로 분류했다.

가장 바깥쪽 레이어부터 인프라스트럭처(infrastructure), 인터페이스(interface), 애플리케이션(application), 도메인(domain)이라고 명명했다.

이 이름들에 정해진 바는 없다.

필자(한용재, dextor)가 재직중인 회사에서 붙인 방식으로 직관적으로 이해하기 쉽게 작성한 것일 뿐이다.

각 레이어에서 담당하는 컴포넌트는 다음과 같다.

### 1. **인프라스트럭처(infrastructure) 레이어**

우리가 만드는 애플리케이션에 필요는 하지만 외부에서 가져다 쓰는 컴포넌트를 작성한다.

예를 들어 데이터페이스, 이메일 전송, 다른 서비스와의 통신 프로토콜 구현체 등 외부에서 제공하는 인터페이스나 라이브러리를 이용하여 우리 서비스에 맞게 구현한 구현체가 포함된다.

### 2. **인터페이스(interface) 레이어**

우리 서비스가 제공하는 인터페이스가 구현되는 레이어이다.

앞서 학습했던 컨트롤러는 외부에서 들어오는 요청은 어떤 형식이어야 하고 나가는 데이터는 어떠한지를 제공한다.

마찬가지로 게이트웨이나 프레젠터와 같은 컴포넌트도 외부와의 인터페이스를 담당하고 있다.

### 3. **애플리케이션(application) 레이어**

애플리케이션의 비즈니스 로직이 구현되는 레이어이다.

앞서 배웠던 서비스들이 여기에 존재한다.

유저 서비스의 예를 들면 회원가입, 이메일 인증, 회원정보 조회 등의 로직을 구현한다.

### 4. **도메인(domain) 레이어**

애플리케이션의 핵심 도메인을 구현하는 레이어이다.

도메인 레이어는 다른 레이어에 의존하지 않는다.

따라서 애플리케이션이 가져야 하는 핵심 요소만 가진다

만약 도메인 레이어의 컴포넌트가 변경된다면 이를 이용하는 다른 모든 레이어를 수정해야 하므로 신중하게 작성해야 한다.

클린 아키텍처를 작성하기 위한 또 다른 필수 요소는 DIP(18장)이다.

각 레이어는 의존성이 안쪽 원으로 향한다고 했다.

하지만 **구현을 하기 위해서는 안쪽 원에서 바깥쪽 원의 구현체가 필요한 경우**가 있다.

그러면 구현체가 변경될 경우 함께 수정해야 하므로 독립적이지 않게 된다.

특히 인프라 레이어는 다른 것으로 갈아 끼우는 경우가 종종 발생한다.

예를 들어 DB를 MySQL을 사용하다가 PostgreSQL로 변경하는 일이 있을 수 있다.

이렇게 의존성이 역전되는 경우, **안쪽 레이어에서는 그 레이어 내에서 인터페이스를 정의하고, 인터페이스를 구현한 구현체는 바깥 레이어에 둠으로써 의존성이 역전되지 않도록** 할 수 있다.

<aside>
💡 **은탄환은 없다(프레더릭 브룩스)**

클린 아키텍처가 만능은 아니다.

레이어를 4개로 나누고 각 레이엉로 책임을 분리하게 되면 작성할 코드양은 당연히 늘어난다.

테스트 코드를 작성한다면 테스트 코드도 따라서 늘어난다.

코드양이 늘어난다고 해서 소프트웨어의 복잡도가 떨어진다는 뜻은 아니다.

오히려 레이어별로 코드가 분리되어있기 때문에 코드를 이해하기 쉬워진다.

하지만 조그마한 변경사항이나 추가 기능 구현에도 시간이 오래 걸린다는 단점은 분명히 존재한다.

만약 여러분이 간단한 MVP(minimum viable product)를 만들어 아이디어를 빠르게 검증해보고 싶다면 적합하지 않은 아키텍처일 수 있다.

[!주의!] MVP의 구조가 제품의 구조로 그대로 따라가는 경우는 매우 흔하다.

시간에 쫒겨 상용 제품의 품질을 떨어뜨리는 우를 범하지 않기를 바란다.

</aside>

## 17.2 SOLID 객체 지향 설계 원칙

클린 아키텍처의 바탕에는 SOLID라 불리는 객체 지향 설계 원칙이 깔려 있다.

SOLID는 로버트 C. 마틴이 객체지향 언어로 소프트웨어를 설계할 때의 방법론을 체계적으로 정리한 것이다.

SOLID를 적용하면 유지 보수와 확장이 쉬운 시스템을 만들 수 있다.

더불어 읽고 이해하기 쉬운 코드를 작성하도록 가이드해준다.

SOLID 각 개념이 서로 분리되어 있는 것이 아니라 함께 조합되어 작동해야 더 나은 소프트웨어 구조를 갖출 수 있다.

### 1. SRP: 단일 책임 원칙(single reposibility principle)

> 한 클래스는 하나의 책임만 가져야 한다.
> 

이 원칙을 다르게 풀어서 설명하면, 클래스를 변경하는 이유는 오직 한 가지 뿐이어야 한다는 말이다.

객체 지향 언어를 배울 때 항상 접하는 내용이다.

여기서 클래스는 자바를 비롯한 여러 객체 지향 언어에서 말하는 클래스 그 자체를 의미하는 것은 아니다.

함수, 객체 등 최소 동작의 단위가 되는 개념을 말한다.

코드를 작성하다 보면 어느새 한 클래스가 비대해지는 경우가 발생하기도 한다.

클래스를 크기가 작고 적은 책임을 가지도록 작성해야 변경에 유연하게 대처할 수 있다.

커다란 클래스는 다른 클래스와 의존성이 증가하게 되므로 변경 비용이 더 커지게 된다.

### 2. OCP: 개방-폐쇄 원칙 (open-closed principle)

> 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀 있어야 한다.
> 

얼핏 들으면 상반된 두 개념이 동시에 존재한다고 느껴질 수 있다 .

소프트웨어의 요구 사항이 추가되었다고 해서 기존의 소스코드를 계속 고쳐야 한다면 요구사항이 늘어날수록 유지 보수가 힘들게 된다.

즉, 기능의 추가가 기존 코드에 영향을 끼치지 않도록 하는 구조가 필요하다.

OCP는 인터페이스를 활용하여 쉽게 달성할 수 있다.

필요한 기능이 있다면 그 구현체에 의존하지 말고 인터페이스에 의존하도록 해야 한다.

추가로 필요한 기능이 있다면 인터페이스를 추가하면 된다.

### 3. LSP: 리스코프 치환 원칙 (Liskov substitution principle)

> 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
> 

객체 지향 언어가 가지는 강점이 LSP로 발현된다.

상속 관계에서, 자식 클래스의 인스턴스는 부모 클래스로 선언된 함수의 인수로 전달할 수 있다.

이를 클래스뿐 아니라 인터페이스를 구현한 클래스에서도 마찬가지이다.

실제 동작하는 인스턴스는 인터페이스가 제공하는 기능을 수현한 객체이지만 인터페이스를 사용하는 다른 객체에도 전달할 수 있다.

따라서 실제 구현체인 자식 인스턴스는 언제든지 부모 또는 인터페이스가 제공해야 하는 기능을 제공하는 다른 구현체로 바꿀 수 있다.

### 4. ISP: 인터페이스 분리 원칙 (interface segregation principle)

> 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
> 

하나의 인터페이스에 의존하게 되면 인터페이스에 기능이 추가될 때 인터페이스를 구현하는 모든 클래스를 수정해야 한다.

이렇게 하기 보다는 인터페이스를 기능별로 잘게 쪼개어 특정 플라이언트용 인터페이스로 모아 사용하는 것이 변경에 대해 의존성을 낮추고 유연하게 대처할 수있는 방법이다.

### 5. DIP: 의존관계 역전 원칙 (dependency inversion principle)

> 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.
> 

DIP는 6장의 쉬어가는 페이지에서 소개한 DI와 매우 밀접한 관계를 가지고 있다.

클린 아키텍처를 구현하기 위해서는 의존관계 역전이 발생하기 마련이고 이를 해소하기 위해 DI를 이용해야 한ㄷ.

DI는 보통 프레임워크에서 제공하며, 혹은 DI를 구현할 수 있는 라이브러리를 이용한다.

이상으로 SOLID의 개념에 대해 알아봤다

그러면 도대체 어느 정도의 해상도로 SOLID를 구현해야 할까?

클래스와 인터페이스는 어느정도 잘게 나누고, 역할을 분리해야 할까?

그것은 정해진 바가 없다.

시스템 발전에 따라 영향도는 낮추고 응집도는 높이는 방향으로 끊임없이 리팩터링해서 달성해야 한다.

만약 여러분의 코드에서 불쾌한 냄새(code smell)가 난다면 언제든지 리팩터링을 할 준비를 해야 할 것이다.

## 17.3 유저 서비스에 클린 아키텍처 적용하기

지금까지는 레이어를 명확하게 구분하지 않았다.

기능별 역할에 따라 UserModule, ExceptionModule, LoggingModule과 같이 모듈로만 분리했다.

각 모듈은 모든 모듈이 사용하는 공통 모듈이 될 수도 있고, MSA의 관점에서 완전히 분리하여 별개의 백엔드 서버 시스템으로 만들 수도 있다.

예를 들어 EmailModule을 물리적으로 다른 환경에서 운용되는 EmailService로 분리할 수도 있다.

이제 우리가 작성하고 있느 ㄴ유저 서비스에서 유저 모듈로 그 범위를 좁혀 클린 아키텍처를 적용해보겠다.

[17.3 유저 서비스에 클린 아키텍처 적용하기](https://www.notion.so/17-3-a18a1aa019bb4dc0a7756db817f229e1?pvs=21)