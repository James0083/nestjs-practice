# 4. 프로바이더(provider)

> 앱이 제공하고자 하는 핵심 기능(=비즈니스 로직)을 수행
> 
> 
> provider는 service, repository, factory, helper 등 여러가지 형태로 구현됨
> 

- `@Injectable()` 데커레이터를 선언함으로써 다른 어떤 Nest 컴포넌트에서도 주입할 수 있는 프로바이더가 됨.
- 별도의 scope를 지정해주지 않으면 일반적으로 싱글턴 인스턴스가 생성됨.

## 프로바이더 등록과 사용

1. 등록
    
    모듈에 사용할 수 있도록 등록해줘야 한다. (nest명령어를 이용해 생성 시, 자동으로 추가됨)
    
    ```tsx
    @Module({
    	...
    	providers: [UsersService]
    })
    export class UserModule {}
    ```
    
    `@Injectable()` 데코레이터로 의존성 주입을 지원하고, 프로바이더로 등록. 
    
2. 사용
    
    `@Inject(속성명)` 데커레이터로 입한다. (`@Injectable()`이 선언된 클래스는 클래스 이름 타입을 쓰면됨.)
    

** 상속받는 클래스가 프로바이더를 주입받지 않았다면, (혹은 프로바이더를 직접 주입하지 않고 상속관계에 있는 자식 클래스를 주입받아 사용하고 싶다면)

상속관계에서 **생성자 기반 주입을 받을 때**는 하위 클래스가 super를 통해 상위 클래스에 필요한 프로바이더를 전달해 줘야 한다.

## 스코프

> p.79
> 

Node.js는 다른 웹 프레임뭐크와는 다르게, 멀티 스레드 상태 비저장(stateless)모델을 따르지 않는다.

따라서 싱글턴 인스턴스를 사용하는 것은 안전한 방식이다.

이는 요청으로 들어오는 모든 정보(DB 커넥션 풀, 전역 싱글턴 서비스 등)들을 공유할 수 있다는 것을 의미한다.

하지만 GraphQL 애플리케이션의 요청별 캐싱을 한다거나 요청을 추적하거나 또는 멀티테넌시(multitenancy)를 지원하기 위해서는 요청 기반으로 생명주기를 제한해야 한다.

(multitenancy - 하나의 애플리케이션 인스턴스가 여러 사용자에게 각각 다르게 동작하도록 하는 SW아키텍처. 반대로 각 사용자마다 인스턴스가 새로 만들어지도록 하는 멀티 인스턴스 방식이 있다. 하지만 요즘 대부분의 서비스는 멀티테넌시 방식을 채택하고 있음.)
---

컨트롤러와 프로바이더에 스코프(scope)옵션을 주어 생명주기를 지정하는 방법이 있다.

- 스코프 종류
    - **DEFAULT**
        - 싱글턴 인스턴스가 전체 애플리케이션에서 공유됨.
        - 인스턴스 수명은 애플리케이션 생명주기와 같다.
        - 애플리케이션이 부트스트랩 과정을 마치면 모든 싱글턴 프로바이더의 인스턴스가 만들어진다.
        - 따로 선언하지 않으면 DEFAULT가 적용된다.
    - **REQUEST**
        - 들어오는 요청마다 별도의 인스턴스가 생성됨.
        - 요청을 처리하고 나면 인스턴스는 garbage-collected됨.
    - **TRANSIENT**
        - ‘임시’라는 의미로 이 스코프를 지정한 인스턴스는 공유되지 않음.
        - 이 프로바이더를 주입하는 각 컴포넌트는 새로 생성된 전용 인스턴스를 주입받게 됨.
    
    가능하면 **DEFAULT** 스코프를 사용하는 것을 권장한다. 싱글턴 인스턴스를 공유한다는 것은 인스턴스를 캐시할 수 있고, 초기화가 애플리케이션 시작 중에 한 번만 발생하므로 메모리와 동작 성능을 향상할 수 있다.
    

### 프로바이더에 스코프 적용하기

`@Injectable` 데커레이터에 scope속성을 주는 방법.

```tsx
import { Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.REQUEST })
export class CatsService {}
```

커스텀 프로바이더를 사용할 때도 마찬가지임.

```tsx
{
	provide: 'CACHE_MANAGER',
	useClass: CacheManager,
	scope: Scope.TRANSIENT,
}
```

### 컨트롤러에 스코프 적용하기

`@Controller` 데커레이터는 ControllerOptions를 인수로 받을 수 있다.  

ControllerOptions는 ScopeOptions를 상속한다.

```tsx
export declare function Controller(options: ControllerOptions): ClassDecorator;

export interface ControllerOptions extends ScopeOptions, VersionOptions {
	path?: string | string[];
	host?: string | RegExp | Array<string | RegExp>;
}

export interface ScopeOptions {
	scope?: Scope;
}

//스코프 속성 전달
@Controller({
	path: 'cats', 
	scope: Scope.REQUEST,
})
export class CatsController {}
```

### 스코프 계층

스코프 계층(scope hierarchy)은 컴포넌트가 가질 수 있는 스코프의 범위를 나타낸다.

스코프는 컨트롤러와 프로바이더에 선언할 수 있는데 만약 연관된 컴포넌트들이 서로 다른 스코프를 가지게 된다면

예를 들어 CatsController ⇒ CatsService ⇒ CatsRepository 같은 종속성 그래프를 가지고 있는 상태에서 CatService는 REQUEST 스코프를 가지고, 나머지는 모두 DEFAULT 스코프를 가질 경우를 가정.

이때 CatsController는 CatsService에 의존적이기 때문에 REQUEST로 변경됨.

하지만 CatsRepository는 CatsService에 의존하지 않으므로 그대로 DEFAULT로 남음. 

종속성을 가진 컴포넌트의 스코프를 따라간다.

## 커스텀 프로바이더

> p.82 참고
