# 8. 영속화 : 데이터를 기록하고 다루기

Nest는 다양한 데이터베이스와 연결할 수 있다. 

Node.js드라이버가 존재하는 데이터베이스가 있다면 가져다 적용할 수 있다. 

RDBMS는 물론 NoSQL DB도 가능하다.

또한 MikroORM, Sequelize, Knex.js, TypeORM, Prisma 같은 ORM을 지원한다.

만약 ORM을 사용하지 않겠다고 하면 Node.js에서 지원하는 데이터베이스 라이브러리를 사용하면 된다. 

여기서는 MySQL과 TypeORM을 이용하여 데이터를 다루겠다.

<aside>
💡 ************************************객체 관계 매핑************************************(object-relational mapping, **ORM**)이란 데이터베이스의 관계를 객체로 바꾸어 개발자가 OOP로 데이터베이스를 쉽게 다룰 수 있도록 해주는 도구이다. 
SQL문을 그대로 코드에 기술하고 그 결과를 뭐리셋으로 다루는 방식에서 세부 쿼리문을 추상화 하는 것으로 발전했다. 
개발자는 ORM에서 제공하는 인터페이스를 통해 일반적인 라이브러리를 호출하듯 DB에 데이터를 업데이트 하고 조회할 수 있다.

</aside>

## 8.1 MySQL 데이터베이스 설정

다른 프로젝트와 개발환경을 분리하기 위해 도커를 이용하여 실행.

MySQL버전은 8로 지정함. 

DB에 연결할 때 Username은 root, Password는 test로 설정.

더 자세한 내용은 [도커 허브의 가이드](http://hub.docker.com/_/mysql) 참조

```bash
# docker에서 mysql 버전 8 설치
$ docker run --name mysql-local -p 3306:3306/tcp -e MYSQL_ROOT_PASSWORD=test -d mysql:8

# mysql이 잘 실행되고 있는지 확인 
$ docker ps
CONTAINER ID   IMAGE     COMMAND                   CREATED         STATUS         PORTS                               NAMES
bc2971c3c0af   mysql:8   "docker-entrypoint.s…"   3 minutes ago   Up 3 minutes   0.0.0.0:3306->3306/tcp, 33060/tcp   mysql-local
```

데이터베이스와 테이블을 생성하거나 데이터를 조회하고 조작하기 위해서 DB클라이언트 툴을 사용
(콘솔에서 작업해도 됨)

[DBeaver](https://dbeaver.io/download/) 사용.

실행 후 Connection 메뉴에서 MySQL을 선택 → Server Host 와 Password등을 입력.

![img1.daumcdn.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/380da689-6e0b-4496-b9c4-07070d4b592a/a891ba65-3ef3-44bb-b97d-0faf4a709849/img1.daumcdn.png)

MySQL 8.0부터는 ‘Driver properties’에서 퍼블릭 키(public key) 등록을 허용해줘야 한다. 

Driver properties - allowPublicKeyRetrieval ⇒ TRUE

테스트를 위해서 데이터베이스 하나 생성. (Database name : test)

한글 정렬이 잘 되도록 하기 위해 Charset : utf8mb4 , Collation : utf8mb4_unicode_ci

![캡처16.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/380da689-6e0b-4496-b9c4-07070d4b592a/f0dc0900-cf3a-42c5-8d4c-9c2e0da6b4b1/%EC%BA%A1%EC%B2%9816.png)

## 8.2 TypeORM으로 데이터베이스 연결

Nest에서 제공하는 데이터베이스 연결에 대한 기본적인 내용은 생략.

[유저서비스](https://www.notion.so/a4dc74d753894f12abe67bf810f87e53?pvs=21)에서 데이터베이스를 연결해서 데이터를 다루겠음.

MySQL과 TypeORM 외의 도구를 사용하겠다면 공식 문서를 참고.

## 8.3 회원 가입을 요청한 유저의 정보 저장하기

[8.3 회원 가입을 요청한 유저의 정보 저장하기](https://www.notion.so/8-3-625728610b604f469197e0dc29db7f66?pvs=21) 

## 8.4 [트랜잭션](https://www.notion.so/transaction-cc586bb9af7b4d0c8c78b46b56140ffd?pvs=21) 적용

[8.4 [트랜잭션](https://www.notion.so/transaction-cc586bb9af7b4d0c8c78b46b56140ffd?pvs=21) 적용](https://www.notion.so/8-4-d43b20668c014d4986b3c2554b1bf74e?pvs=21) 

## 8.5 마이그레이션

넓은 의미의 마이그레이션(migration)은 애플리케이션이 구동되는 OS를 바꾸거나 데이터베이스를 MySQL에서 Oracle로 바꾸는 것과 같이 인프라를 교체하는 것을 포함한다. 

데이터베이스를 다룰 때에도 마이그레이션이라는 용어를 자주 접하게 된다.

서비스를 개발하다 보면 데이터베이스 스키마를 변경할 일이 빈번하게 발생한다. 

신기능을 추가하면서 새로운 테이블을 생성하기도 하고 테이블 필드의 이름이나 속성을 변경해야 하는 일도 생긴다. 

만약 이전에 저장해둔 데이터가 현재의 도메인 구조와 다르다면 모든 데이터의 값을 수정할 일도 생긴다 .

이러한 과정 역시 마이그레이션이라고 부른다 

TypeORM은 마이그레이션을 쉽고 안전하게 하는 방법을 제공한다. 

TypeORM 마이그레이션을 사용하면 **여러 이점**을 얻을 수 있다.

### 첫째

마이그레이션을 위한 SQL문을 직접 작성하지 않아도 된다. 

직접 데이터 스키마를 생성, 수정, 삭제하며 두려움을 느껴본 이들이라면 TypeORM 마이그레이션이 자동으로 생성해주는 마이그레이션 코드에 안도감을 느낄 것이다. 

또 만약 마이그레이션이 잘못 적용되었다면 마지막 적용한 마이드레기션 사항을 되돌리는 작업도 간단히 명령어로 수행할 수 있다. 

### 둘째

롤링 업데이트가 가능한 마이그레이션이 아니라면 적용하기 전에 DB를 백업하는 것을 잊지 말아야 한다. 

TypeORM 마이그레이션을 이용하면 마이그레이션 코드를 일정한 형식으로 소스 저장소에서 관리할 수 있다. 

즉 데이터베이스의 변경점을 소스코드로 관리할 수 있다는 뜻이다. 

소스코드로 관리할 때의 또 다른 장점은 코드 리뷰가 가능하다는 점이다. 

마이그레이션 코드가 자동으로 생성되기는 하지만 직접 추가코드를 넣을 경우도 생긴다. 

사내 코드리뷰 프로세스에 따라 리뷰어가 승인한 코드는 더 탄탄한 코드가 된다. 

SQL문을 직접 작성해서 특정 디렉터리에 모아서 보관할 수도 있겠지만 TypeORM이 제공하는 일관된 형식을 사용하면 이미 해당 지식을 가진 신규 개발자가 쉽게 적응할 수 있다. 

### 마지막으로

TypeORM 마이그레이션을 적용하여 마이그레이션 이력을 관리할 수 있다. 언제 어떤 마이그레이션이 일어났는지를 특정 테이블에 기록하고 필요한 경우 처음부터 순서대로 다시 수행할 수도 있다. 

<aside>
💡 TypeORM을 사용하지 않는다면 자신이 사용하는 ORM이 제공하는 마이그레이션 툴을 찾아보자.

예를 들어 Sequelize의 경우에도 마이그레이션을 제공한다. 

</aside>

적용 실습 : [8.5 마이그레이션 ](https://www.notion.so/8-5-2866e1fb08e94274a9f141bcabccad41?pvs=21) 

## [쉬어가기] 저장소 패턴

저장소 패턴(repository pattern)은 데이터베이스와 같은 저장소를 다루는 로직을 데이터 레이어로 분리하여 핵심 비즈니스 로직에 집중할 수 있도록 해준다. 

저장소는 인터페이스를 통해 데이터를 처리하도록 추상화되어 있으므로 필요할 경우 데이터 저장소를 변경하기 쉽다는 장점도 가진다. 

마틴 파울러는 <엔터프라이즈 애플리케이션 아키텍처 패턴>(위키북스, 2015)에서 저장소를 다음과 같이 기술했다. 

> 저장소는 도메인 모델 계층과 데이터 매핑의 중간자 역할을 하며 메모리 내의 도메인 개체 집합에 대해서도 비슷한 방식으로 작업을 수행한다.
> 
> 
> 클라이언트 객체는 쿼리를 선언적으로 빌드하고 저장소에 요청한다. 
> 
> 개념적으로 저장소는 데이터베이스에 저장되는 객체 집합과 그것들에 대해 수행하는 작업을 캡슐화해서 영속화 계층에 더 가까운 방법을 제공한다. 
> 
> 저장소는 또한 작업 도메인 및 데이터 할당 또는 매핑 간의 종속성을 명확하게 한 방향으로 구분하려는 목적을 지원한다.
> 

다음 [그림](https://docs.microsoft.com/ko-kr/previous-versions/msp-n-p/ff649690(v=pandp.10))을 보면 비즈니스 로직을 처리하는 클라이언트는 직접 데이터 소스를 다루지 않는다. 

저장소를 활용하여 엔티티 객체를 영속화 하고, 역시 저장소를 통해 데이터를 비즈니스 엔티티 개체로 전달받는다. 

영속화, 쿼리 요청과 응답을 가공하는 저장소는 데이터 소스에 맞는 구현체를 가진다.

![ff649690.4058e458-bd54-4597-845e-6f8b1a21cfc3(en-us,pandp.10).png](https://prod-files-secure.s3.us-west-2.amazonaws.com/380da689-6e0b-4496-b9c4-07070d4b592a/3801ea18-1352-404f-896d-748d2aef1da2/ff649690.4058e458-bd54-4597-845e-6f8b1a21cfc3(en-uspandp.10).png)

즉, 데이터를 데이터베이스에 저장하기 적합하게 매핑을 하고 쿼리 결과를 클라이언트가 원하는 방식으로 가공한다. 

만약 데이터베이스를 MySQL에서 PostgrSQL로 변경하고자 한다면 클라이언트와의 인터페이스는 그대로 두고 구현부만 적합하게 변경하면 된다.